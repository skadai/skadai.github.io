{
  "version": "https://jsonfeed.org/version/1",
  "title": "长安路",
  "home_page_url": "https://skadai.github.io",
  "feed_url": "https://skadai.github.io/feed/feed.json",
  "description": "sk blog",
  "author": {
    "name": "sk",
    "url": ""
  },
  "items": [{
      "id": "https://skadai.github.io/posts/flask_caching/",
      "url": "https://skadai.github.io/posts/flask_caching/",
      "title": "利用 flask_caching 添加缓存",
      "content_html": "<h4 id=\"%E8%83%8C%E6%99%AF\">背景 <a class=\"direct-link\" href=\"#%E8%83%8C%E6%99%AF\">#</a></h4>\n<p>工作中接到反馈，我负责的服务在跑数过程中经常会遇到一些业务逻辑的变化而重刷数据，相同的数据要反复的请求服务，而服务中用到了深度学习模型，比较耗时，因此希望添加缓存</p>\n<h4 id=\"%E9%9C%80%E6%B1%82\">需求 <a class=\"direct-link\" href=\"#%E9%9C%80%E6%B1%82\">#</a></h4>\n<ol>\n<li>为服务添加缓存，收到服务之后，优先查询缓存，缓存没有才去调用服务</li>\n<li>如果请求返回的是exception error， 不需要缓存（有可能是model 服务不稳定造成的）</li>\n<li>如果请求中明确说明不用缓存，需要跳过</li>\n</ol>\n<h4 id=\"%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88\">技术方案 <a class=\"direct-link\" href=\"#%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88\">#</a></h4>\n<p>Flask_Caching 库基本可以满足要求 （选择第三方库尽量选择一直有维护的，比如还有一个库 flask_cache已经超过一年没有 commit 了，尽量不要选）</p>\n<h4 id=\"%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD%E5%85%B3%E9%94%AE%E7%82%B9\">具体实施关键点 <a class=\"direct-link\" href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD%E5%85%B3%E9%94%AE%E7%82%B9\">#</a></h4>\n<p>针对需求，进一步考虑实现过程中可能会遇到的问题，有时候未必考虑的清楚，可能需要在实施的时候才能够发现，但是这一步提前考虑是需要做的</p>\n<ol>\n<li>\n<p>用什么作为缓存的key?<br>\n本服务的 api请求  是json格式的POST， 我们需要用请求的字段作为key</p>\n</li>\n<li>\n<p>缓存过期时间？<br>\n缓存可以设置自动失效时间，因为 ETL 一般重刷任务间隔时间是比较短的，通过配置参数 CACHE_DEFAULT_TIMEOUT 在cache初始化的时候传入即可，cache在到期之后会自动删除掉，这样不需要为每个函数单独指定失效时间</p>\n</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\">    <span class=\"token keyword\">from</span> flask <span class=\"token keyword\">import</span> Flask<br>    <span class=\"token keyword\">from</span> flask_caching <span class=\"token keyword\">import</span> Cache<br>    config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token string\">\"DEBUG\"</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>          <span class=\"token comment\"># some Flask specific configs</span><br>        <span class=\"token string\">\"CACHE_TYPE\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"SimpleCache\"</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># Flask-Caching related configs</span><br>        <span class=\"token string\">\"CACHE_DEFAULT_TIMEOUT\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">300</span><br>    <span class=\"token punctuation\">}</span><br>    app <span class=\"token operator\">=</span> Flask<span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span><br>    <span class=\"token comment\"># tell Flask to use the above defined config</span><br>    app<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>from_mapping<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><br>    cache <span class=\"token operator\">=</span> Cache<span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span></code></pre>\n<ol start=\"3\">\n<li>如何实现当服务有正常结果的时候就缓存，没有正常结果的时候就不缓存<br>\n通过查看 flask_caching的文档发现,  这个库是通过添加 caching.cached 装饰器来实现缓存的<br>\n@app.route(&quot;/&quot;)<br>\n@cache.cached(timeout=50)<br>\ndef index():<br>\nreturn render_template('index.html')</li>\n</ol>\n<p>进一步去看 cache.cached 本身的代码(省略无关的代码),</p>\n<ul>\n<li>函数本身返回的是一个装饰器</li>\n<li>有下面的字段是和要不要设置缓存相关的\n<ul>\n<li>response_filter:   发生在主逻辑计算之后，对结果进行过滤，比如我们可以设置如果结果是500错误就不缓存了</li>\n<li>unless: 发生在主逻辑计算之前,  可以设置一个特殊条件，如果满足，那么不走缓存（也不会保存缓存了）</li>\n</ul>\n</li>\n</ul>\n<p>我们希望发生 500错误不需要缓存，那么response_filter这个参数比较符合要求，此外还有一个比较隐蔽的做法，就是如果路由函数执行的死后抛出了异常，这个时候异常交给单独的error handler 处理，其实也是不会保存缓存的</p>\n<blockquote>\n<p>Alternately, looking at the code for Flask-Cache it appears it<br>\ndoes not handle errors thrown by the view<br>\n. So you could   simply raise the error yourself and handle the exception with a separate handler:<br>\n摘自 stack overflow</p>\n</blockquote>\n<p>由于开发时候没有仔细看文档😢，具体实现采用的是“比较隐蔽的做法”， response_filter 应该更加直观。</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">cached</span><span class=\"token punctuation\">(</span><br>    self<span class=\"token punctuation\">,</span><br>    timeout<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    key_prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"view/%s\"</span><span class=\"token punctuation\">,</span><br>    unless<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    forced_update<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    response_filter<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    query_string<span class=\"token punctuation\">:</span> <span class=\"token builtin\">bool</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span><br>    hash_method<span class=\"token punctuation\">:</span> Callable <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>md5<span class=\"token punctuation\">,</span><br>    cache_none<span class=\"token punctuation\">:</span> <span class=\"token builtin\">bool</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span><br>    make_cache_key<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    source_check<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Callable<span class=\"token punctuation\">:</span><br>       <span class=\"token triple-quoted-string string\">\"\"\"Decorator. Use this to cache a function. By default the cache key<br>    is `view/request.path`. You are able to use this decorator with any<br>    function by changing the `key_prefix`. If the token `%s` is located<br>    within the `key_prefix` then it will replace that with `request.path`<br>    <br>    Example::<br>    <br>        # An example view function<br>        @cache.cached(timeout=50)<br>        def big_foo():<br>            return big_bar_calc()<br>    <br>        # An example misc function to cache.<br>        @cache.cached(key_prefix='MyCachedList')<br>        def get_list():<br>            return [random.randrange(0, 1) for i in range(50000)]<br>    <br>        my_list = get_list()<br>    <br>    .. note::<br>    <br>        You MUST have a request context to actually called any functions<br>        that are cached.<br>    <br>    .. versionadded:: 0.4<br>        The returned decorated function now has three function attributes<br>        assigned to it. These attributes are readable/writable.<br>    <br>            **uncached**<br>                The original undecorated function<br>    <br>            **cache_timeout**<br>                The cache timeout value for this function. For a<br>                custom value to take affect, this must be set before the<br>                function is called.<br>    <br>            **make_cache_key**<br>                A function used in generating the cache_key used.<br>    <br>                readable and writable<br>    <br>    :param timeout: Default None. If set to an integer, will cache for that<br>                    amount of time. Unit of time is in seconds.<br>    <br>    :param key_prefix: Default 'view/%(request.path)s'. Beginning key to .<br>                       use for the cache key. `request.path` will be the<br>                       actual request path, or in cases where the<br>                       `make_cache_key`-function is called from other<br>                       views it will be the expected URL for the view<br>                       as generated by Flask's `url_for()`.<br>    <br>                       .. versionadded:: 0.3.4<br>                           Can optionally be a callable which takes<br>                           no arguments but returns a string that will<br>                           be used as the cache_key.<br>    <br>    :param unless: Default None. Cache will *always* execute the caching<br>                   facilities unless this callable is true.<br>                   This will bypass the caching entirely.<br>    <br>    :param forced_update: Default None. If this callable is true,<br>                          cache value will be updated regardless cache<br>                          is expired or not. Useful for background<br>                          renewal of cached functions.<br>    <br>    :param response_filter: Default None. If not None, the callable is<br>                            invoked after the cached funtion evaluation,<br>                            and is given one arguement, the response<br>                            content. If the callable returns False, the<br>                            content will not be cached. Useful to prevent<br>                            caching of code 500 responses.<br>    <br>    :param query_string: Default False. When True, the cache key<br>                         used will be the result of hashing the<br>                         ordered query string parameters. This<br>                         avoids creating different caches for<br>                         the same query just because the parameters<br>                         were passed in a different order. See<br>                         _make_cache_key_query_string() for more<br>                         details.<br>    <br>    :param hash_method: Default hashlib.md5. The hash method used to<br>                        generate the keys for cached results.<br>    :param cache_none: Default False. If set to True, add a key exists<br>                       check when cache.get returns None. This will likely<br>                       lead to wrongly returned None values in concurrent<br>                       situations and is not recommended to use.<br>    :param make_cache_key: Default None. If set to a callable object,<br>                       it will be called to generate the cache key<br>    <br>    :param source_check: Default None. If None will use the value set by<br>                         CACHE_SOURCE_CHECK.<br>                         If True, include the function's source code in the<br>                         hash to avoid using cached values when the source<br>                         code has changed and the input values remain the<br>                         same. This ensures that the cache_key will be<br>                         formed with the function's source code hash in<br>                         addition to other parameters that may be included<br>                         in the formation of the key.<br>     <br>    \"\"\"</span><br>    <span class=\"token keyword\">def</span> <span class=\"token function\">decorator</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>        <span class=\"token decorator annotation punctuation\">@functools<span class=\"token punctuation\">.</span>wraps</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">decorated_function</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token comment\">#: Bypass the cache entirely.</span><br>            <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>_bypass_cache<span class=\"token punctuation\">(</span>unless<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br><br>            <span class=\"token keyword\">nonlocal</span> source_check<br>            <span class=\"token keyword\">if</span> source_check <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span><br>                source_check <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>source_check<br><br>            <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span><br>                <span class=\"token comment\"># 首先计算 cached_key </span><br>                <span class=\"token keyword\">if</span> make_cache_key <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span> <span class=\"token keyword\">and</span> <span class=\"token builtin\">callable</span><span class=\"token punctuation\">(</span>make_cache_key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                    cache_key <span class=\"token operator\">=</span> make_cache_key<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span><br>                    cache_key <span class=\"token operator\">=</span> _make_cache_key<span class=\"token punctuation\">(</span><br>                        args<span class=\"token punctuation\">,</span> kwargs<span class=\"token punctuation\">,</span> use_request<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><br>                    <span class=\"token punctuation\">)</span><br>                <br>                <span class=\"token comment\"># 查询缓存</span><br>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><br>                    <span class=\"token builtin\">callable</span><span class=\"token punctuation\">(</span>forced_update<span class=\"token punctuation\">)</span><br>                    <span class=\"token keyword\">and</span> <span class=\"token punctuation\">(</span><br>                        forced_update<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                        <span class=\"token keyword\">if</span> wants_args<span class=\"token punctuation\">(</span>forced_update<span class=\"token punctuation\">)</span><br>                        <span class=\"token keyword\">else</span> forced_update<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>                    <span class=\"token punctuation\">)</span><br>                    <span class=\"token keyword\">is</span> <span class=\"token boolean\">True</span><br>                <span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                    rv <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><br>                    found <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><br>                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span><br>                    rv <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>cache_key<span class=\"token punctuation\">)</span><br>                    found <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span><br><br>                    <span class=\"token comment\"># If the value returned by cache.get() is None, it</span><br>                    <span class=\"token comment\"># might be because the key is not found in the cache</span><br>                    <span class=\"token comment\"># or because the cached value is actually None</span><br>                    <span class=\"token keyword\">if</span> rv <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span><br>                        <span class=\"token comment\"># If we're sure we don't need to cache None values</span><br>                        <span class=\"token comment\"># (cache_none=False), don't bother checking for</span><br>                        <span class=\"token comment\"># key existence, as it can lead to false positives</span><br>                        <span class=\"token comment\"># if a concurrent call already cached the</span><br>                        <span class=\"token comment\"># key between steps. This would cause us to</span><br>                        <span class=\"token comment\"># return None when we shouldn't</span><br>                        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> cache_none<span class=\"token punctuation\">:</span><br>                            found <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><br>                        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span><br>                            found <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>has<span class=\"token punctuation\">(</span>cache_key<span class=\"token punctuation\">)</span><br>            <span class=\"token keyword\">except</span> Exception<span class=\"token punctuation\">:</span><br>                <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">:</span><br>                    <span class=\"token keyword\">raise</span><br>                logger<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span><span class=\"token string\">\"Exception possibly due to cache backend.\"</span><span class=\"token punctuation\">)</span><br>                <span class=\"token comment\"># 如果在查询缓存的时候遇到了错误，就会进入本身的函数计算</span><br>                <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                <br>            <span class=\"token comment\"># 如果没有缓存，执行本身函数</span><br>            <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> found<span class=\"token punctuation\">:</span><br>                <span class=\"token comment\"># 注意这一行, 如果在执行 f(*args, **kwargs)的时候报错，也不会再执行下面的环节了</span><br>                rv <span class=\"token operator\">=</span> f<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                <span class=\"token keyword\">if</span> response_filter <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span> <span class=\"token keyword\">or</span> response_filter<span class=\"token punctuation\">(</span>rv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span><br>                        self<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><br>                            cache_key<span class=\"token punctuation\">,</span><br>                            rv<span class=\"token punctuation\">,</span><br>                            timeout<span class=\"token operator\">=</span>decorated_function<span class=\"token punctuation\">.</span>cache_timeout<span class=\"token punctuation\">,</span><br>                        <span class=\"token punctuation\">)</span><br>                    <span class=\"token keyword\">except</span> Exception<span class=\"token punctuation\">:</span><br>                        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">:</span><br>                            <span class=\"token keyword\">raise</span><br>                        logger<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span><br>                            <span class=\"token string\">\"Exception possibly due to cache backend.\"</span><br>                        <span class=\"token punctuation\">)</span><br>            <span class=\"token keyword\">return</span> rv<br><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">default_make_cache_key</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token comment\"># Convert non-keyword arguments (which is the way</span><br>            <span class=\"token comment\"># `make_cache_key` expects them) to keyword arguments</span><br>            <span class=\"token comment\"># (the way `url_for` expects them)</span><br>            argspec_args <span class=\"token operator\">=</span> inspect<span class=\"token punctuation\">.</span>getfullargspec<span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>args<br><br>            <span class=\"token keyword\">for</span> arg_name<span class=\"token punctuation\">,</span> arg <span class=\"token keyword\">in</span> <span class=\"token builtin\">zip</span><span class=\"token punctuation\">(</span>argspec_args<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                kwargs<span class=\"token punctuation\">[</span>arg_name<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arg<br><br>            <span class=\"token keyword\">return</span> _make_cache_key<span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> kwargs<span class=\"token punctuation\">,</span> use_request<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><br><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">_make_cache_key_query_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token keyword\">pass</span><br><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">_make_cache_key</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> kwargs<span class=\"token punctuation\">,</span> use_request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token keyword\">pass</span><br><br>    <span class=\"token keyword\">return</span> decorator</code></pre>\n<ol start=\"4\">\n<li>如果在请求中显式的声明了不使用缓存，如何跳过缓存<br>\n根据上面的分析，unless 参数其实是可以完美适用的，我们为请求添加一个 bypass 参数，默认是false， 表示优先使用缓存， 如果传入 true, 就跳过缓存 ，然后给 cache.cached 传入 unless 参数为当前请求的bypass参数就好了<br>\n`</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_bypass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>    payload <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>json<br>    <span class=\"token keyword\">return</span> payload<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'bypass'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><br>    <br><br><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/analysis\"</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"POST\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><br><span class=\"token decorator annotation punctuation\">@cache<span class=\"token punctuation\">.</span>cached</span><span class=\"token punctuation\">(</span>key_prefix<span class=\"token operator\">=</span>cache_key<span class=\"token punctuation\">,</span> unless<span class=\"token operator\">=</span>is_bypass<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">def</span> <span class=\"token function\">analysis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>    <span class=\"token comment\"># 主路由函数负责处理 api 调用</span><br>    <span class=\"token keyword\">pass</span></code></pre>\n<ol start=\"5\">\n<li>如何限制缓存的占用空间大小？<br>\nflask_caching 支持多种缓存的后端，可以是可flask 程序同一个进程里面的cache，可以是单独存在文件系统中，可以是redis, memcached 数据库作为缓存后端，甚至可以单独定义一个你自己的缓存后端，只要符合flask_caching所要求的的api接口就可以。<br>\n简单起见，我们用了 redis作为缓存后端，利用 k8s 启动redis container的时候限制一下 redis 占用的最大内存就好了，没有用什么缓存淘汰算法 (比如 LRU )</li>\n</ol>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">    <span class=\"token comment\"># ....以上省略....</span><br>    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> social<span class=\"token punctuation\">-</span>nlp<span class=\"token punctuation\">-</span>redis<br>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> redis<span class=\"token punctuation\">:</span>4.0.14<br>    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">containerPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">6379</span><br>    <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span><br>        <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span><br>        <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 256Mi<br>        <span class=\"token key atrule\">limits</span><span class=\"token punctuation\">:</span><br>        <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 1Gi</code></pre>\n<h4 id=\"%E6%B5%8B%E8%AF%95\">测试 <a class=\"direct-link\" href=\"#%E6%B5%8B%E8%AF%95\">#</a></h4>\n<p>对下面的关键点进行测试，保证改动是可以满足需求的</p>\n<ul>\n<li>测试 unless 参数是够生效 (手动修改传入的参数 bypass 为 true，查看是否有执行到路由函数内部)</li>\n<li>测试 500 错误是不是缓存了（把model svc地址填错构造一个错误）</li>\n<li>测试缓存失效的时候能够正常使用 （关掉redis 服务）</li>\n<li>测试开关缓存时wrk性能区别（&lt;200    =&gt;    1000+）</li>\n</ul>\n<h4 id=\"%E9%99%84%E5%BD%95\">附录 <a class=\"direct-link\" href=\"#%E9%99%84%E5%BD%95\">#</a></h4>\n<ul>\n<li>缓存的简单介绍  <a href=\"https://www.youtube.com/watch?v=U3RkDLtS7uY\">https://www.youtube.com/watch?v=U3RkDLtS7uY</a> (印度小哥飚英语)</li>\n</ul>\n",
      "date_published": "2021-08-15T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/rsshub/",
      "url": "https://skadai.github.io/posts/rsshub/",
      "title": "试用 RSSHub",
      "content_html": "<h4 id=\"rss-%E6%98%AF%E4%BB%80%E4%B9%88\">RSS 是什么 <a class=\"direct-link\" href=\"#rss-%E6%98%AF%E4%BB%80%E4%B9%88\">#</a></h4>\n<p><a href=\"https://en.wikipedia.org/wiki/RSS\">RSS</a> 的全称是 RDF Site Summary 或者 Really Simple Syndication, <s>别问我英文啥意思我不认识</s><br>\n就是让不同的网站的数据都可以用统一的格式进行定义和传输，这样我们可挑选自己感兴趣的网站进行订阅，获取到新的文章集中阅读了，这可以让我们集中阅读感兴趣的文章乃至观看视频，不用在网站上面晃来晃去浪费时间啦</p>\n<h4 id=\"rss-%E9%98%85%E8%AF%BB%E5%99%A8\">RSS 阅读器 <a class=\"direct-link\" href=\"#rss-%E9%98%85%E8%AF%BB%E5%99%A8\">#</a></h4>\n<p>不少网站都提供了下面这个按钮，其实代表的就是rss的意思，点击按钮可以得到一个url，这个url提供的就是和正式网站一直但是样式有别的订阅内容了，通常会是xml格式的文本，所以是没办法方便直接看的。<br>\n<img src=\"http://cdn.glofission.xyz/img/1b1fe7c45939aff7450787a980c29691-20210807171958-32a5c6.png\" alt=\"rss icon\"></p>\n<p>此时呢，我们需要有一个阅读器可以解析这么内容并渲染成良好的格式，比如 mac 用户可以选择 <a href=\"https://reederapp.com/\">reeder</a>。<br>\n使用的方式也是很简单的，直接在reeder中创建一个本地rss账户, 然后添加订阅源</p>\n<p><img src=\"http://cdn.glofission.xyz/img/5587b52eff73570439b162d574847050-20210807173555-f52921.png\" alt=\"reeder操作\"></p>\n<p>然后就可以看到，添加源的文章已经一个个排好等待阅读了，reeder 阅读器已经帮忙渲染好了，可以看到排版还是不错的</p>\n<p><img src=\"http://cdn.glofission.xyz/img/5f62ce7eb780ed571010188fe8765b2d-20210807173835-088b0a.png\" alt=\"reeder article\"></p>\n<h4 id=\"rsshub\">RSSHub <a class=\"direct-link\" href=\"#rsshub\">#</a></h4>\n<p>实际上，很多网站是没有上面那个魔法图标的，比如b站，我们每次就只能进入网站，点击关注的up动态，看有没有投稿，然后再点进去观看了么？</p>\n<p>当然是有更好的办法的，<a href=\"https://github.com/DIYgod/RSSHub\">RSSHub</a> 就是来干这个的</p>\n<blockquote>\n<p>RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容</p>\n</blockquote>\n<p>翻译一下，就是会写代码的人已经帮把一些常用的网站做好了提取rss的方法，只需要有个机器能根据这些方法把网站数据整成标准 RSS 的格式并提供 url 链接，然后我们就像上面那样用就好了。下面的图片展示了 RSSHub 支持了哪些网站，还是相当丰富的</p>\n<p>RSSHub 自己是提供了试用 <a href=\"https://rsshub.app\">demo</a> 的，只需要简单的按照不同网站指定的url格式自己拼接，然后直接粘贴到阅读器里面就完事了！</p>\n<div style=\"display:flex;justify-content:space-between\">\n<img src=\"http://cdn.glofission.xyz/img/9d3beee4c6f6ef1f1228b0b706e80863-20210807175616-dc81cd.png\">\n<img src=\"http://cdn.glofission.xyz/img/179e3b153d7d76dc0497e6f7d4944a2a-20210807175551-b96172.png\">\n</div>\n<h4 id=\"rsshub-%E9%83%A8%E7%BD%B2\">RSSHub 部署 <a class=\"direct-link\" href=\"#rsshub-%E9%83%A8%E7%BD%B2\">#</a></h4>\n<p>官方试用的demo毕竟太多人用，很容易遭到网站的反爬限制，这个时候你可以选择自己部署一个 RSSHub 的服务, RSSHub 的官方文档里面也有 <a href=\"https://docs.rsshub.app/install/\">操作说明</a>, 亲测可用</p>\n<p>下面简单描述下流程，首先得有一个自己的服务器，我用的是 aliyun ECS(单核 内存2GiB, 硬盘40GB)</p>\n<ol>\n<li>\n<p>ssh 登录到服务器</p>\n</li>\n<li>\n<p>拉取 RSSHub 的 Docker 镜像, 不加 tag 的话会直接下载最新的</p>\n</li>\n</ol>\n<pre class=\"language-shell\"><code class=\"language-shell\">docker pull diygod/rsshub</code></pre>\n<blockquote>\n<p>如果没有用过 docker 的话需要自己先安装一下， 可以参考 <a href=\"https://www.runoob.com/docker/ubuntu-docker-install.html\">Ubuntu Docker安装</a></p>\n</blockquote>\n<ol start=\"3\">\n<li>启动镜像</li>\n</ol>\n<pre class=\"language-shell\"><code class=\"language-shell\">docker run -d --name rsshub -p <span class=\"token number\">1200</span>:1200 diygod/rsshub</code></pre>\n<p>稍微解释一下上面这个命令</p>\n<ul>\n<li><code>docker run</code> 就是把镜像启动一个容器跑起来，<code>--name</code> 给容器命名， <code>-d</code> 指定后台运行</li>\n<li><code>-p 1200:1200</code> 并让服务器上面的1200端口和容器内部的1200建立映射，这样在服务器上面访问 localhost:1200 就可以访问到容器里面的服务了，容器内部的端口1200是写死的，但是服务器上面的端口是可以修改的，比如改成8000（如果没有冲突的话）</li>\n</ul>\n<ol start=\"4\">\n<li>服务器安全组加上1200端口, 操作如下</li>\n</ol>\n<p>好吧，其实上面 RSSHub 文档里面都有....</p>\n<p><img src=\"http://cdn.glofission.xyz/img/a070687ca2ed0a117eac459bd2edfbfc-20210807181508-b0ee44.png\" alt=\"add rule\"></p>\n<p><img src=\"https://gitee.com/skadai/bluebird/raw/master/5a4ca0d6c33d77ffef06e1cbe305daef-20210808092442-13a705.png\" alt=\"add rule2\"></p>\n<ol start=\"5\">\n<li>把安全组应用到ECS上面</li>\n</ol>\n<p><img src=\"http://cdn.glofission.xyz/img/c7c495b56bb08bcbbe1b7bc593012e6e-20210807182042-0a7e9a.png\" alt=\"apply rule\"></p>\n<p>上面图片打码的就是服务器的公网 IP了，经过上面一通操作我们在浏览器输入 http://&lt;公网IP&gt;:1200, 看到和上面 RSSHub demo 一样的页面就算部署成功了，之后我们就可以用专属的RSS 提取服务来生成订阅源了🙂</p>\n<p><img src=\"http://cdn.glofission.xyz/img/20dd670b20cc76c57676829ac7ba0657-20210807182335-38e268.png\" alt=\"final page\"></p>\n<hr>\n<p>有个 RSSHub + Reeder 这个组合，就可以很方便添加自己感兴趣的内容了，不用在漫无目的的看了，大大的节省时间（<s>maybe是看了更多有的没的</s>）</p>\n",
      "date_published": "2021-08-07T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/deploy_11ty_in_github-page/",
      "url": "https://skadai.github.io/posts/deploy_11ty_in_github-page/",
      "title": "如何部署11ty到github page",
      "content_html": "<h4 id=\"%E6%B5%81%E7%A8%8B\">流程 <a class=\"direct-link\" href=\"#%E6%B5%81%E7%A8%8B\">#</a></h4>\n<ol>\n<li>\n<p>下载11ty 模板 <a href=\"https://github.com/google/eleventy-high-performance-blog\">https://github.com/google/eleventy-high-performance-blog</a>, 按照提示构建自己的本地博客</p>\n</li>\n<li>\n<p>新增 .nojekyll 文件, 此文件用来告知 github-page 不使用 jekyll 以免产生冲突</p>\n</li>\n<li>\n<p>新增你自己的git仓库, 命名为 &lt;username&gt;.github.io</p>\n</li>\n<li>\n<p>利用下面的命令生成一对秘钥</p>\n</li>\n</ol>\n<pre class=\"language-shell\"><code class=\"language-shell\">    ssh-keygen -t rsa -b <span class=\"token number\">4096</span> -C <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">git</span> config user.email<span class=\"token variable\">)</span></span>\"</span> -f gh-pages -N <span class=\"token string\">\"\"</span></code></pre>\n<ul>\n<li>\n<p>公钥添加到刚刚的仓库 deploy key</p>\n<p><img src=\"http://cdn.glofission.xyz/img/58b01ba0e0ca16a8610e92c1d0d2b661-20210730142442-19f6c1.png\" alt=\"添加公钥\"></p>\n</li>\n<li>\n<p>私钥添加到刚刚的仓库 secret</p>\n<p><img src=\"http://cdn.glofission.xyz/img/a99999f7a1731866c320691fcb87e148-20210730142605-2772eb.png\" alt=\"添加私钥\"></p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>在本地项目新增 .github/workflow/build.yml 文件, 添加下面的内容, 主要逻辑是打包静态文件, 并调用预定义的github action 把<br>\n编译好的文件提交到git仓库</li>\n</ol>\n<pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Eleventy Build<br><br><span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span><br>  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span><br>    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span><br>      <span class=\"token punctuation\">-</span> master<br><br><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span><br>  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span><br>    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest<br>    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2<br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node<br>          <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v1<br>          <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span><br>            <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'14.x'</span><br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> npm ci<br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> npm run build<br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy<br>          <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3<br>          <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span><br>            <span class=\"token key atrule\">deploy_key</span><span class=\"token punctuation\">:</span> $<br>            <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./_site<br></code></pre>\n<blockquote>\n<p>上面文件中 secrets.ACTIONS_DEPLOY_KEY 正好对应了步骤4中配置好的私钥, 这样action中可以向仓库gh-page分支提交编译好的文件</p>\n</blockquote>\n<ol start=\"6\">\n<li>最后一步, 把github-page的source 设置为gh-page, 这样每次往master分支提交内容之后, 就可以触发 action 自动编译文件push到gh-page分支, 你可以在自己的 &lt;username&gt;.github.io 看到最新的博客了</li>\n</ol>\n<h4 id=\"%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\">参考资料 <a class=\"direct-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\">#</a></h4>\n<ul>\n<li><a href=\"https://www.rockyourcode.com/how-to-deploy-eleventy-to-github-pages-with-github-actions/\">https://www.rockyourcode.com/how-to-deploy-eleventy-to-github-pages-with-github-actions/</a></li>\n<li><a href=\"https://www.linkedin.com/pulse/eleventy-github-pages-lea-tortay/\">https://www.linkedin.com/pulse/eleventy-github-pages-lea-tortay/</a></li>\n<li>11ty基本用法\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1zw41197NL?from=search&amp;seid=4624100872590089830\">https://www.bilibili.com/video/BV1zw41197NL?from=search&amp;seid=4624100872590089830</a></li>\n<li><a href=\"https://www.11ty.dev/\">https://www.11ty.dev/</a></li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2021-07-31T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/Starter/",
      "url": "https://skadai.github.io/posts/Starter/",
      "title": "starter",
      "content_html": "<p>定风波</p>\n<p>苏轼</p>\n<blockquote>\n<p>三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。</p>\n</blockquote>\n<p>莫听穿林打叶声，何妨吟啸且徐行。</p>\n<p>竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p>\n<p>料峭春风吹酒醒，微冷，山头斜照却相迎。</p>\n<p>回首向来萧瑟处，归去，也无风雨也无晴</p>\n",
      "date_published": "2021-07-30T00:00:00-00:00"
    }
  ]
}
