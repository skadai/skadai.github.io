{
  "version": "https://jsonfeed.org/version/1",
  "title": "长安路",
  "home_page_url": "https://skadai.github.io",
  "feed_url": "https://skadai.github.io/feed/feed.json",
  "description": "sk blog",
  "author": {
    "name": "sk",
    "url": ""
  },
  "items": [{
      "id": "https://skadai.github.io/posts/dbscan_intro/",
      "url": "https://skadai.github.io/posts/dbscan_intro/",
      "title": "DBSCAN 原理篇",
      "content_html": "<p>本文是<a href=\"https://medium.com/odessa-ml-club/a-journey-to-clustering-introduction-to-dbscan-e724fa899b6f\">meidum odessa-ml-club博客</a>的阅读整理</p>\n<h2 id=\"dbscan-%E8%83%8C%E6%99%AF\">DBSCAN 背景 <a class=\"direct-link\" href=\"#dbscan-%E8%83%8C%E6%99%AF\">#</a></h2>\n<p><strong>1996 年,</strong> 论文 A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise 中提出来该算法, 文章基于一个朴素的假设: 人们是通过类内密度比其他区域要明显的高识别出来类簇的, 反之, 如果只是有一些噪音, 应该是杂乱无章的, 比类簇内部的数据点密度要明显的小。</p>\n<h3 id=\"%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86\">数据划分 <a class=\"direct-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%88%92%E5%88%86\">#</a></h3>\n<p>DBSCAN 将数据分为了三类, 具体来说, 是通过两个参数划分的,  附近[e]范围内含有[u]节点</p>\n<ul>\n<li>core point(cluster center): 附近距离e范围内至少含有u个节点</li>\n<li>border point(cluster margin): 自己本身不是core point但是在其他core point的范围之内</li>\n<li>noise data: 不属于上面的两个范围</li>\n</ul>\n<p>对于相同的数据集, 不同的参数选择得到的数据结果是不同的。</p>\n<h3 id=\"%E6%95%B0%E6%8D%AE%E9%97%B4%E5%85%B3%E7%B3%BB\">数据间关系 <a class=\"direct-link\" href=\"#%E6%95%B0%E6%8D%AE%E9%97%B4%E5%85%B3%E7%B3%BB\">#</a></h3>\n<ol>\n<li>directly density-reachable 两个节点其中一个是core point并且另外一个位于e范围</li>\n<li>density-reachable 一个节点通过多层 directly density-reachable关系可以找到另外一个节点</li>\n<li>存在中间节点c, 节点a和b都满足和c density-reachable, 那么a和b是density connected</li>\n</ol>\n<p>上面三个关系是逐渐变弱的, directly density-reachable更是强调了 core point的概念, 不具有交换性</p>\n<h3 id=\"cluster-%E5%AE%9A%E4%B9%89\">cluster 定义 <a class=\"direct-link\" href=\"#cluster-%E5%AE%9A%E4%B9%89\">#</a></h3>\n<ul>\n<li>数据节点的集合C中, 任意两个都是 density-connected</li>\n<li>任何一个节点属于C, 则这个节点所有 density-connected的节点也属于C</li>\n</ul>\n<p>从节点的定义出发可以得到下面的定理的</p>\n<ol>\n<li>\n<p>对于集合中的 core point来说, 所有节点都是 density-reachable的, 集合就是core point的density-reachable的所有节点的总和 (所有的core point和margin point必然属于某个集合)</p>\n</li>\n<li>\n<p>如果两个集合存在交集, 则交集中的节点全部是 border point</p>\n</li>\n</ol>\n<h3 id=\"%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B\">算法过程 <a class=\"direct-link\" href=\"#%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B\">#</a></h3>\n<ol>\n<li>遍历集合中的所有节点, 为每个节点进行标识</li>\n<li>如果节点已经标识, 跳过, 如果节点没有标, 看是不是 core point, 是的话步骤3, 不是0</li>\n<li>cluster数目加1, 把节点 density-reachable的所有节点都标上</li>\n</ol>\n<blockquote>\n<p>在遍历节点的过程中, 用了 R*-tree 数据结构, 是的算法的时间复杂度为 O(nlgn)</p>\n</blockquote>\n<h3 id=\"%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1%E9%97%AE%E9%A2%98\">参数估计问题 <a class=\"direct-link\" href=\"#%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1%E9%97%AE%E9%A2%98\">#</a></h3>\n<p>算法输入的参数 e 和 u 对于聚类的结果是有明显影响的, 这两个参数如何决定呢?<br>\nDBSCAN的作者在原有模型的基础上提出了 GDBSCAN （参数选择都是程序帮忙完成了）</p>\n<p>通过计算每个节点最近<strong>第k个点</strong>的距离, 降序排列, 可以得到 k-dist plot曲线如下, 对于噪声点距离是比较大的, 如果节点在cluster中距离就比较小的, 所以可以看出曲线会逐渐归于平缓</p>\n<p><img src=\"https://gitee.com/skadai/bluebird/raw/master/b454c66f637a28913fa5d2e13c15c6d6-20210819105939-5aedda.png\" alt=\"4-distance-plot\"></p>\n<p>作者建议选择 e 值在 k-dist-plot 平缓区间和下降区间的交界附近, 对应的横坐标 p * 2 作为u的建议取值</p>\n<h3 id=\"dbscan%E7%9A%84%E9%97%AE%E9%A2%98\">DBSCAN的问题 <a class=\"direct-link\" href=\"#dbscan%E7%9A%84%E9%97%AE%E9%A2%98\">#</a></h3>\n<h4 id=\"%E5%9D%87%E5%8C%80%E6%80%A7%E5%88%86%E5%B8%83%E9%97%AE%E9%A2%98\">均匀性分布问题 <a class=\"direct-link\" href=\"#%E5%9D%87%E5%8C%80%E6%80%A7%E5%88%86%E5%B8%83%E9%97%AE%E9%A2%98\">#</a></h4>\n<p>如果cluster 内部的节点分布是不均匀的, 那么聚类效果就没有那么理想了</p>\n<p><img src=\"https://gitee.com/skadai/bluebird/raw/master/fafb39c2340c9951a7d06a48728cc2c5-20210819110650-3f9454.png\" alt=\"problem\"></p>\n<p>可以通过人工选择参数搞出来比较不错的的结果但是这样其实就属于经验了, 没办法复制</p>\n<p><img src=\"https://gitee.com/skadai/bluebird/raw/master/cd0453978e518201d78a5ee2579e08bc-20210819110705-bd1c89.png\" alt=\"tune\"></p>\n<h4 id=\"overlapping\">overlapping <a class=\"direct-link\" href=\"#overlapping\">#</a></h4>\n<p>当两个cluster之间存在一些交叉区域, 有可能会被染成一个。这个是比较难以处理的，如果把 e 增大, u减少, 相当于削弱了 cluster 限制, 可能cluser都被连成一块, 反之如果e减少, u增加, 加强了cluster 的限制, 可能会出来更多的区域</p>\n<p><img src=\"https://gitee.com/skadai/bluebird/raw/master/962a5c8e9ff0b602fae1bcf39d882085-20210819110721-59d7e4.png\" alt=\"problem\"></p>\n<h3 id=\"%E5%B0%8F%E7%BB%93\">小结 <a class=\"direct-link\" href=\"#%E5%B0%8F%E7%BB%93\">#</a></h3>\n<p>DBSCAN 算法的主要利弊是</p>\n<h4 id=\"%E4%BC%98%E5%8A%BF\">优势 <a class=\"direct-link\" href=\"#%E4%BC%98%E5%8A%BF\">#</a></h4>\n<ol>\n<li>不需要提前给定cluster数目</li>\n<li>对于一些离散很强的点, 很容易干掉</li>\n<li>善于处理cluster形状不规则, distance函数选择丰富</li>\n</ol>\n<h4 id=\"%E5%8A%A3%E5%8A%BF\">劣势 <a class=\"direct-link\" href=\"#%E5%8A%A3%E5%8A%BF\">#</a></h4>\n<ol>\n<li>虽然有经验公式, 参数选择同样是需要微调的</li>\n<li>集合内部分布不均匀, 存在 overlap区域的时候表现不好</li>\n</ol>\n<p>DBSCAN不是完美的, 但是其思想推动了一系列密度相关的聚类算法的提出, 直到现在也是经常被讨论的, 经典地位不可撼动</p>\n<h2 id=\"%E5%8F%82%E8%80%83\">参考 <a class=\"direct-link\" href=\"#%E5%8F%82%E8%80%83\">#</a></h2>\n<ul>\n<li><a href=\"https://medium.com/odessa-ml-club/a-journey-to-clustering-introduction-to-dbscan-e724fa899b6f\">a journey to clustering algorithm</a></li>\n</ul>\n",
      "date_published": "2021-08-18T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/triplet_loss/",
      "url": "https://skadai.github.io/posts/triplet_loss/",
      "title": "Triplet Loss and Online Triplet Mining (翻译)",
      "content_html": "<blockquote>\n<p>工作中碰到一个棘手的问题: 如何从海量商品中找到标准库中的那一个？<br>\n自己尝试过通过纯文本信息（标题, 商品简介, 图片ocr识别出文字）效果不佳, 决定换一个思路看看图像检索能不能提供一些有价值的信息。</p>\n<p>本系列打算结合这个具体的问题, 系统总结下图像检索领域的基本概念</p>\n</blockquote>\n<p><strong>看到了 omoindrot的 <a href=\"https://omoindrot.github.io/triplet-loss\">博客文章</a>对理解 triplet loss 的原理和实现都非常有帮助, 特此翻译</strong></p>\n<h2 id=\"triplet-loss-and-triplet-mining\">Triplet loss and triplet mining <a class=\"direct-link\" href=\"#triplet-loss-and-triplet-mining\">#</a></h2>\n<h3 id=\"%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-softmax\">为什么不用 softmax <a class=\"direct-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-softmax\">#</a></h3>\n<p>Triplet loss (三元组损失) 是谷歌在经典论文 <a href=\"https://arxiv.org/abs/1503.03832\">FaceNet: A Unified Embedding for Face Recognition and Clustering</a> 中提出的一种用来训练人脸 embedding 表征的损失函数。</p>\n<p>和传统的分类问题(固定类别数目, 使用交叉熵损失函数)不同, 人脸识别, 商品检索往往是大量的不确定类别匹配问题, 这个时候更好的做法是判断两个item是不是属于同一个类别。</p>\n<p>三元组损失就是为了上面的应用场景而出现的, 训练目标是来自同一个类别的样本距离要比来自不同类别的样本距离要近, 同一个列表样本形成一个类簇, 不同的类簇之间最好距离足够大。</p>\n<h3 id=\"%E6%8D%9F%E5%A4%B1%E5%AE%9A%E4%B9%89\">损失定义 <a class=\"direct-link\" href=\"#%E6%8D%9F%E5%A4%B1%E5%AE%9A%E4%B9%89\">#</a></h3>\n<p><img src=\"https://omoindrot.github.io/assets/triplet_loss/triplet_loss.png\" alt=\"奥巴马和马克龙损失\"></p>\n<p>三元组损失的目标是在特征空间中满足</p>\n<ol>\n<li>相同标签的样本距离比较近</li>\n<li>不同标签样本距离比较远</li>\n</ol>\n<p>然鹅, 我们不希望让每个标签的样本训练到特别小的空间内（这句话原文 <code>we don’t want to push the train embeddings of each label to collapse into very small clusters</code> 没有太理解, 作者专门解释了附在下面）</p>\n<blockquote>\n<p>When I mentioned that I meant that if you want to do classification or any task based on the embeddings, you only need the intra-cluster distance to be smaller than the inter-cluster distance. If you have that, then two examples from the same class will always have their embeddings closer than two examples from different classes.<br>\nOnce this is done, you don't really need to push the clusters closer together. My intuition is that if you do so, it's a form of overfitting and you will lose in test accuracy.</p>\n<p>In SphereFace they do something similar to softmax. Softmax is also going to push the predictions as close to 0 or to 1 as possible, which is to me a form of overfitting.</p>\n</blockquote>\n<p>啰嗦了半天, 损失具体是这样设计的</p>\n<ul>\n<li>anchor: 锚点样本(query 样本)</li>\n<li>postive: 正样本(和锚点样本标签一样)</li>\n<li>negative: 负样本(和锚点样本标签不一样)</li>\n</ul>\n<p><code>loss = max(d(a, p) - d(a, n) + margin, 0)</code></p>\n<p>损失是锚点和正样本的距离减去负样本距离加上margin, 稍微解释一下<br>\n试想</p>\n<ul>\n<li>如果锚点和正样本距离很近, 和负样本距离很远, 也就是达到我们的理想embedding条件, 此时loss为0</li>\n<li>如果锚点和正样本距离比较近, 和负样本距离比较远, 但是也没远多少, 此时因为有margin的存在, 这种情况loss会是一个 0-margin的值</li>\n<li>锚点和正样本反而比较远, 和负样本比较近, 这个时候 loss 直接大于margin</li>\n</ul>\n<p>上面三种情况分别对应模型区分的简单(easy negative), 中等(semi-hard negative), 困难的(hard negative)情况, 因此loss是一个比一个大的, 下面的图比较生动</p>\n<p><img src=\"https://omoindrot.github.io/assets/triplet_loss/triplets.png\" alt=\"triplet illustration\"></p>\n<h3 id=\"%E4%B8%89%E5%85%83%E7%BB%84%E7%AD%9B%E9%80%89(-triplet-mining)\">三元组筛选( triplet mining) <a class=\"direct-link\" href=\"#%E4%B8%89%E5%85%83%E7%BB%84%E7%AD%9B%E9%80%89(-triplet-mining)\">#</a></h3>\n<p>上面关于三元组损失的定义有了, 只是从原理上大体实现了训练目标, 那么具体实现上选择那些样本作为三元组做法是很多的, 三元组的筛选主要分为 offline and online 两类</p>\n<h4 id=\"offline-mining-(%E4%B8%8D%E5%A5%BD%E7%94%A8)\">offline mining (不好用) <a class=\"direct-link\" href=\"#offline-mining-(%E4%B8%8D%E5%A5%BD%E7%94%A8)\">#</a></h4>\n<p>训练每个epoch之前, 把训练集全部embedding算出来, 找到 semi-hard 和 hard 进行训练, 计算量比较大</p>\n<h4 id=\"online-mining-(%E5%A5%BD%E7%94%A8)\">online mining (好用) <a class=\"direct-link\" href=\"#online-mining-(%E5%A5%BD%E7%94%A8)\">#</a></h4>\n<p>在epoch每个batch训练的时候, 直接来, 不需要遍历全部的训练集, 就在一个小范围上面计算embedding并找到符合要求的</p>\n<h3 id=\"%E5%9C%A8%E7%BA%BF%E7%AD%9B%E9%80%89%E7%AD%96%E7%95%A5\">在线筛选策略 <a class=\"direct-link\" href=\"#%E5%9C%A8%E7%BA%BF%E7%AD%9B%E9%80%89%E7%AD%96%E7%95%A5\">#</a></h3>\n<p>简而言之就是什么样的三元组需要进行训练, 在论文 <a href=\"https://arxiv.org/abs/1703.07737\"> In Defense of the Triplet Loss for Person Re-Identification.</a> 有详述</p>\n<p>假设每个batch size 为 B = PK ,  其中 P表示不同的标签, K表示每个标签挑选的样本数目, 我们只需要在这个小范围内进行挑选合适的三元组</p>\n<h4 id=\"batch-all\">batch all <a class=\"direct-link\" href=\"#batch-all\">#</a></h4>\n<ul>\n<li>选择所有合法的三元组(正样本和anchor同标签, 负样本和anchor标签不同), 刨除掉easy negative之后取平均loss</li>\n<li>总共可能的三元组数目 PK(K-1)(PK-K), 依次表示, anchor可能数目, postive 可能数目, negative 可能数目</li>\n</ul>\n<h4 id=\"batch-hard\">batch hard <a class=\"direct-link\" href=\"#batch-hard\">#</a></h4>\n<ul>\n<li>每一个anchor, 在当前 batch中 选择最困难的正样本(d(a,p) 最大) 和最困难的负样本( d(a, n)最小)形成三元组进行训练</li>\n<li>总共可能的三元组就是 PK, 每个batch就只选择最困难的训练样本进行训练（论文声称这样比 batch all表现好, 好不好不知道, 但是训练时间短是真的）</li>\n</ul>\n<h4 id=\"%E5%90%8E%E7%BB%AD%E7%AB%A0%E8%8A%82(%E7%95%A5)\">后续章节(略) <a class=\"direct-link\" href=\"#%E5%90%8E%E7%BB%AD%E7%AB%A0%E8%8A%82(%E7%95%A5)\">#</a></h4>\n<p>下面是代码实现和示例项目, 直接看原博就好了。 尤其是作者关于 batch hard strategy 的实现, 可谓是赏心悦目, 值得好好学习</p>\n<h4 id=\"%E6%84%9F%E6%83%B3\">感想 <a class=\"direct-link\" href=\"#%E6%84%9F%E6%83%B3\">#</a></h4>\n<p>triplet loss 的思想和之前看过的一个<a href=\"https://github.com/wvangansbeke/Unsupervised-Classification\">文章</a>有一些相似, 都是关注样本内部相同标签和不同标签的差异性, 后者解决的是固定标签数目的无监督分类问题, 直接用图片的变化认为是一个正样本来做, anchor和正样本的距离尽可能小, 配合 self-labelling (把置信度高的直接当成标注数据) 让无监督分类的准确率直接达到了 85% 以上</p>\n<p>对于商品匹配问题, 从类间差异和类内共性出发, 有没有可能挖掘一些弱监督的训练手段呢 ?</p>\n",
      "date_published": "2021-08-17T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/flask_caching/",
      "url": "https://skadai.github.io/posts/flask_caching/",
      "title": "利用 flask_caching 添加缓存",
      "content_html": "<h4 id=\"%E8%83%8C%E6%99%AF\">背景 <a class=\"direct-link\" href=\"#%E8%83%8C%E6%99%AF\">#</a></h4>\n<p>工作中接到反馈，我负责的服务在跑数过程中经常会遇到一些业务逻辑的变化而重刷数据，相同的数据要反复的请求服务，而服务中用到了深度学习模型，比较耗时，因此希望添加缓存</p>\n<h4 id=\"%E9%9C%80%E6%B1%82\">需求 <a class=\"direct-link\" href=\"#%E9%9C%80%E6%B1%82\">#</a></h4>\n<ol>\n<li>为服务添加缓存，收到服务之后，优先查询缓存，缓存没有才去调用服务</li>\n<li>如果请求返回的是exception error， 不需要缓存（有可能是model 服务不稳定造成的）</li>\n<li>如果请求中明确说明不用缓存，需要跳过</li>\n</ol>\n<h4 id=\"%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88\">技术方案 <a class=\"direct-link\" href=\"#%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88\">#</a></h4>\n<p>Flask_Caching 库基本可以满足要求 （选择第三方库尽量选择一直有维护的，比如还有一个库 flask_cache已经超过一年没有 commit 了，尽量不要选）</p>\n<h4 id=\"%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD%E5%85%B3%E9%94%AE%E7%82%B9\">具体实施关键点 <a class=\"direct-link\" href=\"#%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD%E5%85%B3%E9%94%AE%E7%82%B9\">#</a></h4>\n<p>针对需求，进一步考虑实现过程中可能会遇到的问题，有时候未必考虑的清楚，可能需要在实施的时候才能够发现，但是这一步提前考虑是需要做的</p>\n<ol>\n<li>\n<p>用什么作为缓存的key?<br>\n本服务的 api请求  是json格式的POST， 我们需要用请求的字段作为key</p>\n</li>\n<li>\n<p>缓存过期时间？<br>\n缓存可以设置自动失效时间，因为 ETL 一般重刷任务间隔时间是比较短的，通过配置参数 CACHE_DEFAULT_TIMEOUT 在cache初始化的时候传入即可，cache在到期之后会自动删除掉，这样不需要为每个函数单独指定失效时间</p>\n<pre class=\"language-python\"><code class=\"language-python\">    <span class=\"token keyword\">from</span> flask <span class=\"token keyword\">import</span> Flask<br>    <span class=\"token keyword\">from</span> flask_caching <span class=\"token keyword\">import</span> Cache<br>    config <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><br>        <span class=\"token string\">\"DEBUG\"</span><span class=\"token punctuation\">:</span> <span class=\"token boolean\">True</span><span class=\"token punctuation\">,</span>          <span class=\"token comment\"># some Flask specific configs</span><br>        <span class=\"token string\">\"CACHE_TYPE\"</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"SimpleCache\"</span><span class=\"token punctuation\">,</span>  <span class=\"token comment\"># Flask-Caching related configs</span><br>        <span class=\"token string\">\"CACHE_DEFAULT_TIMEOUT\"</span><span class=\"token punctuation\">:</span> <span class=\"token number\">300</span><br>    <span class=\"token punctuation\">}</span><br>    app <span class=\"token operator\">=</span> Flask<span class=\"token punctuation\">(</span>__name__<span class=\"token punctuation\">)</span><br>    <span class=\"token comment\"># tell Flask to use the above defined config</span><br>    app<span class=\"token punctuation\">.</span>config<span class=\"token punctuation\">.</span>from_mapping<span class=\"token punctuation\">(</span>config<span class=\"token punctuation\">)</span><br>    cache <span class=\"token operator\">=</span> Cache<span class=\"token punctuation\">(</span>app<span class=\"token punctuation\">)</span></code></pre>\n</li>\n<li>\n<p>如何实现当服务有正常结果的时候就缓存，没有正常结果的时候就不缓存<br>\n通过查看 flask_caching的文档发现,  这个库是通过添加 caching.cached 装饰器来实现缓存的<br>\n@app.route(&quot;/&quot;)<br>\n@cache.cached(timeout=50)<br>\ndef index():<br>\nreturn render_template('index.html')</p>\n</li>\n</ol>\n<p>进一步去看 cache.cached 本身的代码(省略无关的代码)</p>\n<ul>\n<li>函数本身返回的是一个装饰器</li>\n<li>有下面的字段是和要不要设置缓存相关的\n<ul>\n<li>response_filter:   发生在主逻辑计算之后，对结果进行过滤，比如我们可以设置如果结果是500错误就不缓存了</li>\n<li>unless: 发生在主逻辑计算之前,  可以设置一个特殊条件，如果满足，那么不走缓存（也不会保存缓存了）</li>\n</ul>\n</li>\n</ul>\n<p>我们希望发生 500错误不需要缓存，那么response_filter这个参数比较符合要求，此外还有一个比较隐蔽的做法，就是如果路由函数执行的死后抛出了异常，这个时候异常交给单独的error handler 处理，其实也是不会保存缓存的</p>\n<blockquote>\n<p>Alternately, looking at the code for Flask-Cache it appears it<br>\ndoes not handle errors thrown by the view<br>\n. So you could   simply raise the error yourself and handle the exception with a separate handler:<br>\n摘自 stack overflow</p>\n</blockquote>\n<p>由于开发时候没有仔细看文档😢，具体实现采用的是“比较隐蔽的做法”， response_filter 应该更加直观。</p>\n<pre class=\"language-python\"><code class=\"language-python\"><br><span class=\"token keyword\">def</span> <span class=\"token function\">cached</span><span class=\"token punctuation\">(</span><br>    self<span class=\"token punctuation\">,</span><br>    timeout<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    key_prefix<span class=\"token punctuation\">:</span> <span class=\"token builtin\">str</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"view/%s\"</span><span class=\"token punctuation\">,</span><br>    unless<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    forced_update<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    response_filter<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    query_string<span class=\"token punctuation\">:</span> <span class=\"token builtin\">bool</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span><br>    hash_method<span class=\"token punctuation\">:</span> Callable <span class=\"token operator\">=</span> hashlib<span class=\"token punctuation\">.</span>md5<span class=\"token punctuation\">,</span><br>    cache_none<span class=\"token punctuation\">:</span> <span class=\"token builtin\">bool</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">,</span><br>    make_cache_key<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span>Callable<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br>    source_check<span class=\"token punctuation\">:</span> Optional<span class=\"token punctuation\">[</span><span class=\"token builtin\">bool</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">,</span><br><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span><span class=\"token operator\">></span> Callable<span class=\"token punctuation\">:</span><br>    <span class=\"token triple-quoted-string string\">\"\"\"Decorator. Use this to cache a function. By default the cache key<br>    is `view/request.path`. You are able to use this decorator with any<br>    function by changing the `key_prefix`. If the token `%s` is located<br>    within the `key_prefix` then it will replace that with `request.path`<br>    <br>    Example::<br>    <br>        # An example view function<br>        @cache.cached(timeout=50)<br>        def big_foo():<br>            return big_bar_calc()<br>    <br>        # An example misc function to cache.<br>        @cache.cached(key_prefix='MyCachedList')<br>        def get_list():<br>            return [random.randrange(0, 1) for i in range(50000)]<br>    <br>        my_list = get_list()<br>    <br>    .. note::<br>    <br>        You MUST have a request context to actually called any functions<br>        that are cached.<br>    <br>    .. versionadded:: 0.4<br>        The returned decorated function now has three function attributes<br>        assigned to it. These attributes are readable/writable.<br>    <br>            **uncached**<br>                The original undecorated function<br>    <br>            **cache_timeout**<br>                The cache timeout value for this function. For a<br>                custom value to take affect, this must be set before the<br>                function is called.<br>    <br>            **make_cache_key**<br>                A function used in generating the cache_key used.<br>    <br>                readable and writable<br>    <br>    :param timeout: Default None. If set to an integer, will cache for that<br>                    amount of time. Unit of time is in seconds.<br>    <br>    :param key_prefix: Default 'view/%(request.path)s'. Beginning key to .<br>                    use for the cache key. `request.path` will be the<br>                    actual request path, or in cases where the<br>                    `make_cache_key`-function is called from other<br>                    views it will be the expected URL for the view<br>                    as generated by Flask's `url_for()`.<br>    <br>                    .. versionadded:: 0.3.4<br>                        Can optionally be a callable which takes<br>                        no arguments but returns a string that will<br>                        be used as the cache_key.<br>    <br>    :param unless: Default None. Cache will *always* execute the caching<br>                facilities unless this callable is true.<br>                This will bypass the caching entirely.<br>    <br>    :param forced_update: Default None. If this callable is true,<br>                        cache value will be updated regardless cache<br>                        is expired or not. Useful for background<br>                        renewal of cached functions.<br>    <br>    :param response_filter: Default None. If not None, the callable is<br>                            invoked after the cached funtion evaluation,<br>                            and is given one arguement, the response<br>                            content. If the callable returns False, the<br>                            content will not be cached. Useful to prevent<br>                            caching of code 500 responses.<br>    <br>    :param query_string: Default False. When True, the cache key<br>                        used will be the result of hashing the<br>                        ordered query string parameters. This<br>                        avoids creating different caches for<br>                        the same query just because the parameters<br>                        were passed in a different order. See<br>                        _make_cache_key_query_string() for more<br>                        details.<br>    <br>    :param hash_method: Default hashlib.md5. The hash method used to<br>                        generate the keys for cached results.<br>    :param cache_none: Default False. If set to True, add a key exists<br>                    check when cache.get returns None. This will likely<br>                    lead to wrongly returned None values in concurrent<br>                    situations and is not recommended to use.<br>    :param make_cache_key: Default None. If set to a callable object,<br>                    it will be called to generate the cache key<br>    <br>    :param source_check: Default None. If None will use the value set by<br>                        CACHE_SOURCE_CHECK.<br>                        If True, include the function's source code in the<br>                        hash to avoid using cached values when the source<br>                        code has changed and the input values remain the<br>                        same. This ensures that the cache_key will be<br>                        formed with the function's source code hash in<br>                        addition to other parameters that may be included<br>                        in the formation of the key.<br>    <br>    \"\"\"</span><br>    <span class=\"token keyword\">def</span> <span class=\"token function\">decorator</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>        <span class=\"token decorator annotation punctuation\">@functools<span class=\"token punctuation\">.</span>wraps</span><span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">decorated_function</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token comment\">#: Bypass the cache entirely.</span><br>            <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>_bypass_cache<span class=\"token punctuation\">(</span>unless<span class=\"token punctuation\">,</span> f<span class=\"token punctuation\">,</span> <span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br><br>            <span class=\"token keyword\">nonlocal</span> source_check<br>            <span class=\"token keyword\">if</span> source_check <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span><br>                source_check <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>source_check<br><br>            <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span><br>                <span class=\"token comment\"># 首先计算 cached_key </span><br>                <span class=\"token keyword\">if</span> make_cache_key <span class=\"token keyword\">is</span> <span class=\"token keyword\">not</span> <span class=\"token boolean\">None</span> <span class=\"token keyword\">and</span> <span class=\"token builtin\">callable</span><span class=\"token punctuation\">(</span>make_cache_key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                    cache_key <span class=\"token operator\">=</span> make_cache_key<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span><br>                    cache_key <span class=\"token operator\">=</span> _make_cache_key<span class=\"token punctuation\">(</span><br>                        args<span class=\"token punctuation\">,</span> kwargs<span class=\"token punctuation\">,</span> use_request<span class=\"token operator\">=</span><span class=\"token boolean\">True</span><br>                    <span class=\"token punctuation\">)</span><br>                <br>                <span class=\"token comment\"># 查询缓存</span><br>                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><br>                    <span class=\"token builtin\">callable</span><span class=\"token punctuation\">(</span>forced_update<span class=\"token punctuation\">)</span><br>                    <span class=\"token keyword\">and</span> <span class=\"token punctuation\">(</span><br>                        forced_update<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                        <span class=\"token keyword\">if</span> wants_args<span class=\"token punctuation\">(</span>forced_update<span class=\"token punctuation\">)</span><br>                        <span class=\"token keyword\">else</span> forced_update<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><br>                    <span class=\"token punctuation\">)</span><br>                    <span class=\"token keyword\">is</span> <span class=\"token boolean\">True</span><br>                <span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                    rv <span class=\"token operator\">=</span> <span class=\"token boolean\">None</span><br>                    found <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><br>                <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span><br>                    rv <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span>cache_key<span class=\"token punctuation\">)</span><br>                    found <span class=\"token operator\">=</span> <span class=\"token boolean\">True</span><br><br>                    <span class=\"token comment\"># If the value returned by cache.get() is None, it</span><br>                    <span class=\"token comment\"># might be because the key is not found in the cache</span><br>                    <span class=\"token comment\"># or because the cached value is actually None</span><br>                    <span class=\"token keyword\">if</span> rv <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span><span class=\"token punctuation\">:</span><br>                        <span class=\"token comment\"># If we're sure we don't need to cache None values</span><br>                        <span class=\"token comment\"># (cache_none=False), don't bother checking for</span><br>                        <span class=\"token comment\"># key existence, as it can lead to false positives</span><br>                        <span class=\"token comment\"># if a concurrent call already cached the</span><br>                        <span class=\"token comment\"># key between steps. This would cause us to</span><br>                        <span class=\"token comment\"># return None when we shouldn't</span><br>                        <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> cache_none<span class=\"token punctuation\">:</span><br>                            found <span class=\"token operator\">=</span> <span class=\"token boolean\">False</span><br>                        <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span><br>                            found <span class=\"token operator\">=</span> self<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span>has<span class=\"token punctuation\">(</span>cache_key<span class=\"token punctuation\">)</span><br>            <span class=\"token keyword\">except</span> Exception<span class=\"token punctuation\">:</span><br>                <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">:</span><br>                    <span class=\"token keyword\">raise</span><br>                logger<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span><span class=\"token string\">\"Exception possibly due to cache backend.\"</span><span class=\"token punctuation\">)</span><br>                <span class=\"token comment\"># 如果在查询缓存的时候遇到了错误，就会进入本身的函数计算</span><br>                <span class=\"token keyword\">return</span> f<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                <br>            <span class=\"token comment\"># 如果没有缓存，执行本身函数</span><br>            <span class=\"token keyword\">if</span> <span class=\"token keyword\">not</span> found<span class=\"token punctuation\">:</span><br>                <span class=\"token comment\"># 注意这一行, 如果在执行 f(*args, **kwargs)的时候报错，也不会再执行下面的环节了</span><br>                rv <span class=\"token operator\">=</span> f<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><br>                <span class=\"token keyword\">if</span> response_filter <span class=\"token keyword\">is</span> <span class=\"token boolean\">None</span> <span class=\"token keyword\">or</span> response_filter<span class=\"token punctuation\">(</span>rv<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                    <span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span><br>                        self<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">.</span><span class=\"token builtin\">set</span><span class=\"token punctuation\">(</span><br>                            cache_key<span class=\"token punctuation\">,</span><br>                            rv<span class=\"token punctuation\">,</span><br>                            timeout<span class=\"token operator\">=</span>decorated_function<span class=\"token punctuation\">.</span>cache_timeout<span class=\"token punctuation\">,</span><br>                        <span class=\"token punctuation\">)</span><br>                    <span class=\"token keyword\">except</span> Exception<span class=\"token punctuation\">:</span><br>                        <span class=\"token keyword\">if</span> self<span class=\"token punctuation\">.</span>app<span class=\"token punctuation\">.</span>debug<span class=\"token punctuation\">:</span><br>                            <span class=\"token keyword\">raise</span><br>                        logger<span class=\"token punctuation\">.</span>exception<span class=\"token punctuation\">(</span><br>                            <span class=\"token string\">\"Exception possibly due to cache backend.\"</span><br>                        <span class=\"token punctuation\">)</span><br>            <span class=\"token keyword\">return</span> rv<br><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">default_make_cache_key</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">**</span>kwargs<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token comment\"># Convert non-keyword arguments (which is the way</span><br>            <span class=\"token comment\"># `make_cache_key` expects them) to keyword arguments</span><br>            <span class=\"token comment\"># (the way `url_for` expects them)</span><br>            argspec_args <span class=\"token operator\">=</span> inspect<span class=\"token punctuation\">.</span>getfullargspec<span class=\"token punctuation\">(</span>f<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span>args<br><br>            <span class=\"token keyword\">for</span> arg_name<span class=\"token punctuation\">,</span> arg <span class=\"token keyword\">in</span> <span class=\"token builtin\">zip</span><span class=\"token punctuation\">(</span>argspec_args<span class=\"token punctuation\">,</span> args<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>                kwargs<span class=\"token punctuation\">[</span>arg_name<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> arg<br><br>            <span class=\"token keyword\">return</span> _make_cache_key<span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> kwargs<span class=\"token punctuation\">,</span> use_request<span class=\"token operator\">=</span><span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><br><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">_make_cache_key_query_string</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token keyword\">pass</span><br><br>        <span class=\"token keyword\">def</span> <span class=\"token function\">_make_cache_key</span><span class=\"token punctuation\">(</span>args<span class=\"token punctuation\">,</span> kwargs<span class=\"token punctuation\">,</span> use_request<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>            <span class=\"token keyword\">pass</span><br><br>    <span class=\"token keyword\">return</span> decorator</code></pre>\n<ol start=\"4\">\n<li>如果在请求中显式的声明了不使用缓存，如何跳过缓存?<br>\n根据上面的分析，unless 参数其实是可以完美适用的，我们为请求添加一个 bypass 参数，默认是false， 表示优先使用缓存， 如果传入 true, 就跳过缓存 ，然后给 cache.cached 传入 unless 参数为当前请求的bypass参数就好了</li>\n</ol>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">is_bypass</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>    payload <span class=\"token operator\">=</span> request<span class=\"token punctuation\">.</span>json<br>    <span class=\"token keyword\">return</span> payload<span class=\"token punctuation\">.</span>get<span class=\"token punctuation\">(</span><span class=\"token string\">'bypass'</span><span class=\"token punctuation\">,</span> <span class=\"token boolean\">False</span><span class=\"token punctuation\">)</span><br>    <br><br><span class=\"token decorator annotation punctuation\">@app<span class=\"token punctuation\">.</span>route</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/analysis\"</span><span class=\"token punctuation\">,</span> methods<span class=\"token operator\">=</span><span class=\"token punctuation\">[</span><span class=\"token string\">\"POST\"</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><br><span class=\"token decorator annotation punctuation\">@cache<span class=\"token punctuation\">.</span>cached</span><span class=\"token punctuation\">(</span>key_prefix<span class=\"token operator\">=</span>cache_key<span class=\"token punctuation\">,</span> unless<span class=\"token operator\">=</span>is_bypass<span class=\"token punctuation\">)</span><br><span class=\"token keyword\">def</span> <span class=\"token function\">analysis</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><br>    <span class=\"token comment\"># 主路由函数负责处理 api 调用</span><br>    <span class=\"token keyword\">pass</span></code></pre>\n<ol start=\"5\">\n<li>如何限制缓存的占用空间大小？<br>\nflask_caching 支持多种缓存的后端，可以是可flask 程序同一个进程里面的cache，可以是单独存在文件系统中，可以是redis, memcached 数据库作为缓存后端，甚至可以单独定义一个你自己的缓存后端，只要符合flask_caching所要求的的api接口就可以。<br>\n简单起见，我们用了 redis作为缓存后端，利用 k8s 启动redis container的时候限制一下 redis 占用的最大内存就好了，没有用什么缓存淘汰算法 (比如 LRU )</li>\n</ol>\n<pre class=\"language-yaml\"><code class=\"language-yaml\">    <span class=\"token comment\"># ....以上省略....</span><br>    <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> social<span class=\"token punctuation\">-</span>nlp<span class=\"token punctuation\">-</span>redis<br>    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> redis<span class=\"token punctuation\">:</span>4.0.14<br>    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">containerPort</span><span class=\"token punctuation\">:</span> <span class=\"token number\">6379</span><br>    <span class=\"token key atrule\">resources</span><span class=\"token punctuation\">:</span><br>        <span class=\"token key atrule\">requests</span><span class=\"token punctuation\">:</span><br>        <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 256Mi<br>        <span class=\"token key atrule\">limits</span><span class=\"token punctuation\">:</span><br>        <span class=\"token key atrule\">memory</span><span class=\"token punctuation\">:</span> 1Gi</code></pre>\n<h4 id=\"%E6%B5%8B%E8%AF%95\">测试 <a class=\"direct-link\" href=\"#%E6%B5%8B%E8%AF%95\">#</a></h4>\n<p>对下面的关键点进行测试，保证改动是可以满足需求的</p>\n<ul>\n<li>测试 unless 参数是够生效 (手动修改传入的参数 bypass 为 true，查看是否有执行到路由函数内部)</li>\n<li>测试 500 错误是不是缓存了（把model svc地址填错构造一个错误）</li>\n<li>测试缓存失效的时候能够正常使用 （关掉redis 服务）</li>\n<li>测试开关缓存时wrk性能区别（&lt;200    =&gt;    1000+）</li>\n</ul>\n<h4 id=\"%E9%99%84%E5%BD%95\">附录 <a class=\"direct-link\" href=\"#%E9%99%84%E5%BD%95\">#</a></h4>\n<ul>\n<li>缓存的简单介绍  <a href=\"https://www.youtube.com/watch?v=U3RkDLtS7uY\">https://www.youtube.com/watch?v=U3RkDLtS7uY</a> (印度小哥飚英语)</li>\n</ul>\n",
      "date_published": "2021-08-15T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/rsshub/",
      "url": "https://skadai.github.io/posts/rsshub/",
      "title": "试用 RSSHub",
      "content_html": "<h4 id=\"rss-%E6%98%AF%E4%BB%80%E4%B9%88\">RSS 是什么 <a class=\"direct-link\" href=\"#rss-%E6%98%AF%E4%BB%80%E4%B9%88\">#</a></h4>\n<p><a href=\"https://en.wikipedia.org/wiki/RSS\">RSS</a> 的全称是 RDF Site Summary 或者 Really Simple Syndication, <s>别问我英文啥意思我不认识</s><br>\n就是让不同的网站的数据都可以用统一的格式进行定义和传输，这样我们可挑选自己感兴趣的网站进行订阅，获取到新的文章集中阅读了，这可以让我们集中阅读感兴趣的文章乃至观看视频，不用在网站上面晃来晃去浪费时间啦</p>\n<h4 id=\"rss-%E9%98%85%E8%AF%BB%E5%99%A8\">RSS 阅读器 <a class=\"direct-link\" href=\"#rss-%E9%98%85%E8%AF%BB%E5%99%A8\">#</a></h4>\n<p>不少网站都提供了下面这个按钮，其实代表的就是rss的意思，点击按钮可以得到一个url，这个url提供的就是和正式网站一直但是样式有别的订阅内容了，通常会是xml格式的文本，所以是没办法方便直接看的。<br>\n<img src=\"http://cdn.glofission.xyz/img/1b1fe7c45939aff7450787a980c29691-20210807171958-32a5c6.png\" alt=\"rss icon\"></p>\n<p>此时呢，我们需要有一个阅读器可以解析这么内容并渲染成良好的格式，比如 mac 用户可以选择 <a href=\"https://reederapp.com/\">reeder</a>。<br>\n使用的方式也是很简单的，直接在reeder中创建一个本地rss账户, 然后添加订阅源</p>\n<p><img src=\"http://cdn.glofission.xyz/img/5587b52eff73570439b162d574847050-20210807173555-f52921.png\" alt=\"reeder操作\"></p>\n<p>然后就可以看到，添加源的文章已经一个个排好等待阅读了，reeder 阅读器已经帮忙渲染好了，可以看到排版还是不错的</p>\n<p><img src=\"http://cdn.glofission.xyz/img/5f62ce7eb780ed571010188fe8765b2d-20210807173835-088b0a.png\" alt=\"reeder article\"></p>\n<h4 id=\"rsshub\">RSSHub <a class=\"direct-link\" href=\"#rsshub\">#</a></h4>\n<p>实际上，很多网站是没有上面那个魔法图标的，比如b站，我们每次就只能进入网站，点击关注的up动态，看有没有投稿，然后再点进去观看了么？</p>\n<p>当然是有更好的办法的，<a href=\"https://github.com/DIYgod/RSSHub\">RSSHub</a> 就是来干这个的</p>\n<blockquote>\n<p>RSSHub 是一个开源、简单易用、易于扩展的 RSS 生成器，可以给任何奇奇怪怪的内容生成 RSS 订阅源。RSSHub 借助于开源社区的力量快速发展中，目前已适配数百家网站的上千项内容</p>\n</blockquote>\n<p>翻译一下，就是会写代码的人已经帮把一些常用的网站做好了提取rss的方法，只需要有个机器能根据这些方法把网站数据整成标准 RSS 的格式并提供 url 链接，然后我们就像上面那样用就好了。下面的图片展示了 RSSHub 支持了哪些网站，还是相当丰富的</p>\n<p>RSSHub 自己是提供了试用 <a href=\"https://rsshub.app\">demo</a> 的，只需要简单的按照不同网站指定的url格式自己拼接，然后直接粘贴到阅读器里面就完事了！</p>\n<div style=\"display:flex;justify-content:space-between\">\n<img src=\"http://cdn.glofission.xyz/img/9d3beee4c6f6ef1f1228b0b706e80863-20210807175616-dc81cd.png\">\n<img src=\"http://cdn.glofission.xyz/img/179e3b153d7d76dc0497e6f7d4944a2a-20210807175551-b96172.png\">\n</div>\n<h4 id=\"rsshub-%E9%83%A8%E7%BD%B2\">RSSHub 部署 <a class=\"direct-link\" href=\"#rsshub-%E9%83%A8%E7%BD%B2\">#</a></h4>\n<p>官方试用的demo毕竟太多人用，很容易遭到网站的反爬限制，这个时候你可以选择自己部署一个 RSSHub 的服务, RSSHub 的官方文档里面也有 <a href=\"https://docs.rsshub.app/install/\">操作说明</a>, 亲测可用</p>\n<p>下面简单描述下流程，首先得有一个自己的服务器，我用的是 aliyun ECS(单核 内存2GiB, 硬盘40GB)</p>\n<ol>\n<li>\n<p>ssh 登录到服务器</p>\n</li>\n<li>\n<p>拉取 RSSHub 的 Docker 镜像, 不加 tag 的话会直接下载最新的</p>\n</li>\n</ol>\n<pre class=\"language-shell\"><code class=\"language-shell\">docker pull diygod/rsshub</code></pre>\n<blockquote>\n<p>如果没有用过 docker 的话需要自己先安装一下， 可以参考 <a href=\"https://www.runoob.com/docker/ubuntu-docker-install.html\">Ubuntu Docker安装</a></p>\n</blockquote>\n<ol start=\"3\">\n<li>启动镜像</li>\n</ol>\n<pre class=\"language-shell\"><code class=\"language-shell\">docker run -d --name rsshub -p <span class=\"token number\">1200</span>:1200 diygod/rsshub</code></pre>\n<p>稍微解释一下上面这个命令</p>\n<ul>\n<li><code>docker run</code> 就是把镜像启动一个容器跑起来，<code>--name</code> 给容器命名， <code>-d</code> 指定后台运行</li>\n<li><code>-p 1200:1200</code> 并让服务器上面的1200端口和容器内部的1200建立映射，这样在服务器上面访问 localhost:1200 就可以访问到容器里面的服务了，容器内部的端口1200是写死的，但是服务器上面的端口是可以修改的，比如改成8000（如果没有冲突的话）</li>\n</ul>\n<ol start=\"4\">\n<li>服务器安全组加上1200端口, 操作如下</li>\n</ol>\n<p>好吧，其实上面 RSSHub 文档里面都有....</p>\n<p><img src=\"http://cdn.glofission.xyz/img/a070687ca2ed0a117eac459bd2edfbfc-20210807181508-b0ee44.png\" alt=\"add rule\"></p>\n<p><img src=\"https://gitee.com/skadai/bluebird/raw/master/5a4ca0d6c33d77ffef06e1cbe305daef-20210808092442-13a705.png\" alt=\"add rule2\"></p>\n<ol start=\"5\">\n<li>把安全组应用到ECS上面</li>\n</ol>\n<p><img src=\"http://cdn.glofission.xyz/img/c7c495b56bb08bcbbe1b7bc593012e6e-20210807182042-0a7e9a.png\" alt=\"apply rule\"></p>\n<p>上面图片打码的就是服务器的公网 IP了，经过上面一通操作我们在浏览器输入 http://&lt;公网IP&gt;:1200, 看到和上面 RSSHub demo 一样的页面就算部署成功了，之后我们就可以用专属的RSS 提取服务来生成订阅源了🙂</p>\n<p><img src=\"http://cdn.glofission.xyz/img/20dd670b20cc76c57676829ac7ba0657-20210807182335-38e268.png\" alt=\"final page\"></p>\n<hr>\n<p>有个 RSSHub + Reeder 这个组合，就可以很方便添加自己感兴趣的内容了，不用在漫无目的的看了，大大的节省时间（<s>maybe是看了更多有的没的</s>）</p>\n",
      "date_published": "2021-08-07T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/deploy_11ty_in_github-page/",
      "url": "https://skadai.github.io/posts/deploy_11ty_in_github-page/",
      "title": "如何部署11ty到github page",
      "content_html": "<h4 id=\"%E6%B5%81%E7%A8%8B\">流程 <a class=\"direct-link\" href=\"#%E6%B5%81%E7%A8%8B\">#</a></h4>\n<ol>\n<li>\n<p>下载11ty 模板 <a href=\"https://github.com/google/eleventy-high-performance-blog\">https://github.com/google/eleventy-high-performance-blog</a>, 按照提示构建自己的本地博客</p>\n</li>\n<li>\n<p>新增 .nojekyll 文件, 此文件用来告知 github-page 不使用 jekyll 以免产生冲突</p>\n</li>\n<li>\n<p>新增你自己的git仓库, 命名为 &lt;username&gt;.github.io</p>\n</li>\n<li>\n<p>利用下面的命令生成一对秘钥</p>\n</li>\n</ol>\n<pre class=\"language-shell\"><code class=\"language-shell\">    ssh-keygen -t rsa -b <span class=\"token number\">4096</span> -C <span class=\"token string\">\"<span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">git</span> config user.email<span class=\"token variable\">)</span></span>\"</span> -f gh-pages -N <span class=\"token string\">\"\"</span></code></pre>\n<ul>\n<li>\n<p>公钥添加到刚刚的仓库 deploy key</p>\n<p><img src=\"http://cdn.glofission.xyz/img/58b01ba0e0ca16a8610e92c1d0d2b661-20210730142442-19f6c1.png\" alt=\"添加公钥\"></p>\n</li>\n<li>\n<p>私钥添加到刚刚的仓库 secret</p>\n<p><img src=\"http://cdn.glofission.xyz/img/a99999f7a1731866c320691fcb87e148-20210730142605-2772eb.png\" alt=\"添加私钥\"></p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>在本地项目新增 .github/workflow/build.yml 文件, 添加下面的内容, 主要逻辑是打包静态文件, 并调用预定义的github action 把<br>\n编译好的文件提交到git仓库</li>\n</ol>\n<pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Eleventy Build<br><br><span class=\"token key atrule\">on</span><span class=\"token punctuation\">:</span><br>  <span class=\"token key atrule\">push</span><span class=\"token punctuation\">:</span><br>    <span class=\"token key atrule\">branches</span><span class=\"token punctuation\">:</span><br>      <span class=\"token punctuation\">-</span> master<br><br><span class=\"token key atrule\">jobs</span><span class=\"token punctuation\">:</span><br>  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span><br>    <span class=\"token key atrule\">runs-on</span><span class=\"token punctuation\">:</span> ubuntu<span class=\"token punctuation\">-</span>latest<br>    <span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/checkout@v2<br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Setup Node<br>          <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> actions/setup<span class=\"token punctuation\">-</span>node@v1<br>          <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span><br>            <span class=\"token key atrule\">node-version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'14.x'</span><br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> npm ci<br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">run</span><span class=\"token punctuation\">:</span> npm run build<br><br>        <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> Deploy<br>          <span class=\"token key atrule\">uses</span><span class=\"token punctuation\">:</span> peaceiris/actions<span class=\"token punctuation\">-</span>gh<span class=\"token punctuation\">-</span>pages@v3<br>          <span class=\"token key atrule\">with</span><span class=\"token punctuation\">:</span><br>            <span class=\"token key atrule\">deploy_key</span><span class=\"token punctuation\">:</span> $<br>            <span class=\"token key atrule\">publish_dir</span><span class=\"token punctuation\">:</span> ./_site<br></code></pre>\n<blockquote>\n<p>上面文件中 secrets.ACTIONS_DEPLOY_KEY 正好对应了步骤4中配置好的私钥, 这样action中可以向仓库gh-page分支提交编译好的文件</p>\n</blockquote>\n<ol start=\"6\">\n<li>最后一步, 把github-page的source 设置为gh-page, 这样每次往master分支提交内容之后, 就可以触发 action 自动编译文件push到gh-page分支, 你可以在自己的 &lt;username&gt;.github.io 看到最新的博客了</li>\n</ol>\n<h4 id=\"%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\">参考资料 <a class=\"direct-link\" href=\"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99\">#</a></h4>\n<ul>\n<li><a href=\"https://www.rockyourcode.com/how-to-deploy-eleventy-to-github-pages-with-github-actions/\">https://www.rockyourcode.com/how-to-deploy-eleventy-to-github-pages-with-github-actions/</a></li>\n<li><a href=\"https://www.linkedin.com/pulse/eleventy-github-pages-lea-tortay/\">https://www.linkedin.com/pulse/eleventy-github-pages-lea-tortay/</a></li>\n<li>11ty基本用法\n<ul>\n<li><a href=\"https://www.bilibili.com/video/BV1zw41197NL?from=search&amp;seid=4624100872590089830\">https://www.bilibili.com/video/BV1zw41197NL?from=search&amp;seid=4624100872590089830</a></li>\n<li><a href=\"https://www.11ty.dev/\">https://www.11ty.dev/</a></li>\n</ul>\n</li>\n</ul>\n",
      "date_published": "2021-07-31T00:00:00-00:00"
    },{
      "id": "https://skadai.github.io/posts/Starter/",
      "url": "https://skadai.github.io/posts/Starter/",
      "title": "starter",
      "content_html": "<p>定风波</p>\n<p>苏轼</p>\n<blockquote>\n<p>三月七日，沙湖道中遇雨。雨具先去，同行皆狼狈，余独不觉，已而遂晴，故作此词。</p>\n</blockquote>\n<p>莫听穿林打叶声，何妨吟啸且徐行。</p>\n<p>竹杖芒鞋轻胜马，谁怕？一蓑烟雨任平生。</p>\n<p>料峭春风吹酒醒，微冷，山头斜照却相迎。</p>\n<p>回首向来萧瑟处，归去，也无风雨也无晴</p>\n",
      "date_published": "2021-07-30T00:00:00-00:00"
    }
  ]
}
